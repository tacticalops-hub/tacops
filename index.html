<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CODM Tactical Map Guides</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  
  <!-- PWA Meta Tags -->
  <meta name="description" content="Interactive tactical map guides for Call of Duty Mobile with drawing tools and route planning">
  <meta name="theme-color" content="#00aaff">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="CODM Maps">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json?v=1.0.2">
  
  <!-- PWA Icons -->
  <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-72x72.png">
  <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-72x72.png">
  <link rel="apple-touch-icon" href="icons/icon-152x152.png">
  <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-152x152.png">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B99CVFWBGB"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-B99CVFWBGB');
  </script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      display: flex;
      min-height: 100vh;
      background-color: #111;
      color: #f0f0f0;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    .sidebar {
      width: 220px;
      background-color: #1a1a1a;
      padding: 1rem;
      height: 100vh;
      box-sizing: border-box;
      border-right: 1px solid #333;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 100;
      transition: transform 0.3s ease;
      transform: translateX(0);
      overflow-y: auto !important;
      max-height: 100vh !important;
    }

    .sidebar h2 {
      font-size: 1.3rem;
      margin-top: 0;
      margin-bottom: 1rem;
      color: #0af;
    }

    .map-selector {
      width: 220px;
      background: #181c24;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.18);
      padding: 0.7rem 0.7rem 1.1rem 0.7rem;
      margin-bottom: 1.5rem;
      border: 2px solid #0af;
      position: static;
      left: unset;
      top: unset;
      z-index: 1;
      display: block;
      box-sizing: border-box;
    }

    .map-selector label {
      color: #0af;
      font-weight: bold;
      margin-bottom: 0.5rem;
      font-size: 1.05rem;
      display: block;
      text-align: left;
    }

    .map-selector select {
      width: 100%;
      font-size: 1.1rem;
      padding: 0.6rem 0.5rem;
      border-radius: 10px;
      background: #232a36;
      color: #0af;
      border: 1.5px solid #0af;
      font-family: inherit;
      font-weight: bold;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      outline: none;
      transition: background 0.2s, color 0.2s;
      box-sizing: border-box;
      margin-bottom: 0;
      margin-top: 0;
    }

    .map-selector select:focus {
      background: #1a2330;
      color: #fff;
      border: 2px solid #0af;
    }

    .whiteboard-controls {
      margin-top: 1rem;
    }

    .whiteboard-controls button {
      width: 100%;
      padding: 0.8rem;
      margin-top: 0.5rem;
      display: block;
      border-radius: 8px;
      border: none;
      background-color: #2a2a2a;
      color: #f0f0f0;
      font-weight: bold;
      font-family: monospace;
      font-size: 1rem;
      transition: background 0.2s;
      cursor: pointer;
    }

    .whiteboard-controls button:hover {
      background-color: #0af;
      color: #000;
    }

    main {
      padding: 2rem;
      margin-left: 240px;
      width: calc(100% - 240px);
      box-sizing: border-box;
    }

    h1 {
      margin: 0;
      padding: 1rem;
      color: #0af;
      font-size: 1.5rem;
      text-align: center;
      position: relative;
      z-index: 1;
    }

    .map-entry {
      position: relative;
      width: auto;
      margin: 0 auto 2rem;
      padding: 1rem;
      background: #1a1a1a;
      border: 1px solid #444;
    }

    .map-container {
      position: relative;
      width: fit-content;
      height: auto;
      margin: 0 auto;
      max-height: 100vw;
      overflow: visible !important;
    }

    .map-container img {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .map-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: crosshair;
      border: 2px solid #00ff00;
      /* width: auto !important; */
      /* height: auto !important; */
    }

    /* Override mobile canvas sizing to allow JavaScript control */
    @media (max-width: 768px) {
      .map-container canvas {
        width: auto !important;
        height: auto !important;
        position: absolute !important;
      }
    }

    .map-entry h2 {
      margin: 0 0 1rem 0;
      color: #fff;
      text-align: center;
    }

    .controls {
      margin-top: 1rem;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .controls input,
    .controls select {
      padding: 8px;
      background-color: #333;
      color: #fff;
      border: 1px solid #444;
      border-radius: 4px;
      font-size: 1em;
    }

    .controls button {
      padding: 8px 16px;
      background-color: #333;
      color: #fff;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.2s;
    }

    .controls button:hover {
      background-color: #444;
    }

    .text-marker {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.9rem;
      cursor: move;
      user-select: none;
      z-index: 10;
    }

    .text-marker:focus {
      outline: 3px solid #0af;
      outline-offset: 2px;
    }

    footer {
      background-color: #222;
      padding: 1rem;
      text-align: center;
      font-size: 0.9rem;
      position: fixed;
      bottom: 0;
      left: 220px;
      right: 0;
    }

    .keyboard-instructions {
      background: #222;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      border: 1px solid #0af;
    }

    .board-input {
      width: 100%;
      padding: 0.8rem;
      margin-bottom: 0.5rem;
      background-color: #2a2a2a;
      color: #f0f0f0;
      border: 1px solid #444;
      border-radius: 8px;
      font-size: 1rem;
    }

    .board-select {
      width: 100%;
      padding: 0.8rem;
      margin-bottom: 0.5rem;
      background-color: #2a2a2a;
      color: #f0f0f0;
      border: 1px solid #444;
      border-radius: 8px;
      font-size: 1rem;
    }

    .board-input:focus,
    .board-select:focus {
      outline: 2px solid #0af;
      border-color: #0af;
    }

    @media (max-width: 768px) {
      html, body, main {
        width: 100vw !important;
        max-width: 100vw !important;
        overflow-x: hidden !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      h1 {
        display: none !important;
      }
      .sidebar {
        width: 280px !important;
        min-width: 280px !important;
        max-width: 280px !important;
        position: fixed;
        left: 0;
        top: 0;
        height: 100vh;
        z-index: 200;
        transform: translateX(-100%) !important;
        transition: transform 0.3s cubic-bezier(.4,0,.2,1);
        padding: 1.5rem !important;
        overflow-y: auto !important;
        max-height: 100vh !important;
      }
      .sidebar.open {
        transform: translateX(0) !important;
      }
      .sidebar-toggle {
        position: fixed;
        top: 18px;
        left: 10px;
        z-index: 300;
        transition: left 0.3s cubic-bezier(.4,0,.2,1);
        padding: 1rem 1.5rem !important;
        font-size: 1.5rem !important;
        border-radius: 8px !important;
      }
      .sidebar.open ~ .sidebar-toggle {
        left: 290px;
      }
      .whiteboard-controls button {
        padding: 1.2rem !important;
        margin-top: 0.8rem !important;
        font-size: 1.2rem !important;
        border-radius: 12px !important;
        min-height: 60px !important;
      }
      .board-input, .board-select {
        padding: 1.2rem !important;
        font-size: 1.2rem !important;
        margin-bottom: 0.8rem !important;
        border-radius: 12px !important;
        min-height: 50px !important;
      }
      main {
        margin-left: 0 !important;
        width: 100vw !important;
        padding: 0 !important;
        position: relative;
        z-index: 1;
        margin-top: 5.5rem !important;
      }
      .map-container {
        width: 100vw !important;
        max-width: 100vw !important;
        height: 100vh !important;
        max-height: 100vh !important;
        margin: 0 !important;
        position: relative;
        background: none;
        z-index: 1;
      }
      .map-container img {
        width: 100% !important;
        max-width: 100vw !important;
        height: auto !important;
        display: block;
        object-fit: contain;
      }
      .map-selector {
        position: fixed;
        top: 1rem;
        left: 80px;
        width: calc(100vw - 100px);
        max-width: 350px;
        z-index: 250;
        background: #181c24;
        border-radius: 16px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        padding: 1rem 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #222;
        transition: left 0.3s cubic-bezier(.4,0,.2,1);
      }
      .map-selector select {
        width: 100%;
        background: #232a36;
        color: #0af;
        border: none;
        border-radius: 12px;
        padding: 1rem 1.2rem;
        font-size: 1.5rem;
        font-family: inherit;
        font-weight: bold;
        letter-spacing: 0.5px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        outline: none;
        transition: background 0.2s, color 0.2s;
        min-height: 60px;
      }
      .map-selector select:focus {
        background: #1a2330;
        color: #fff;
        border: 2px solid #0af;
      }
      .text-marker {
        font-size: 1.1rem !important;
        padding: 8px 12px !important;
        border-radius: 8px !important;
        min-height: 40px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
    }
    /* Sidebar toggle button for mobile */
    .sidebar-toggle {
      display: none;
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 200;
      background: #0af;
      color: #111;
      border: none;
      border-radius: 6px;
      padding: 0.7rem 1.2rem;
      font-size: 1.2rem;
      font-weight: bold;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      cursor: pointer;
    }
    @media (max-width: 768px) {
      .sidebar-toggle {
        display: block;
      }
    }
    .fab {
      display: none;
      position: fixed;
      right: 24px;
      bottom: 24px;
      z-index: 300;
      flex-direction: column;
      align-items: flex-end;
      gap: 12px;
    }
    .fab-main {
      background: #0af;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 70px;
      height: 70px;
      font-size: 2.5rem;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    .fab-main:active {
      background: #08c;
    }
    .fab-menu {
      display: none;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
      margin-bottom: 8px;
      pointer-events: none;
    }
    .fab.open .fab-menu {
      display: flex;
      pointer-events: auto;
    }
    .fab-action {
      background: #222;
      color: #0af;
      border: none;
      border-radius: 12px;
      padding: 20px 28px;
      font-size: 1.4rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      cursor: pointer;
      min-width: 160px;
      text-align: right;
      transition: background 0.2s, color 0.2s;
      font-weight: bold;
    }
    .fab-action:active {
      background: #0af;
      color: #fff;
    }
    .sidebar-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.4);
      z-index: 150;
    }
    .sidebar.open ~ .sidebar-overlay {
      display: block;
    }
    @media (min-width: 769px) {
      .sidebar-overlay {
        display: none !important;
      }
    }
    html, body {
      width: 100vw;
    }

    .upload-section {
      width: 220px;
      background: #181c24;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.18);
      padding: 0.7rem 0.7rem 1.1rem 0.7rem;
      margin-bottom: 1.5rem;
      border: 2px solid #0af;
      box-sizing: border-box;
    }

    .upload-section label {
      color: #0af;
      font-weight: bold;
      margin-bottom: 0.5rem;
      font-size: 1.05rem;
      display: block;
      text-align: left;
    }

    .upload-btn {
      width: 100%;
      padding: 0.6rem;
      border-radius: 10px;
      background: #232a36;
      color: #0af;
      border: 1.5px solid #0af;
      font-family: inherit;
      font-weight: bold;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      outline: none;
    }

    .upload-btn:hover {
      background: #1a2330;
      color: #fff;
      border: 2px solid #0af;
    }

    .upload-status {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #0af;
      text-align: center;
      min-height: 1.2rem;
    }

    .upload-status.error {
      color: #ff4444;
    }

    .upload-status.success {
      color: #44ff44;
    }

    /* Uploaded maps list styling */
    .uploaded-maps-list {
      margin-bottom: 0.8rem;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #0af;
      border-radius: 8px;
      background: #232a36;
      display: none; /* Hidden by default, shown when maps exist */
    }

    .uploaded-maps-list:not(:empty) {
      display: block;
    }

    .uploaded-map-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.7rem;
      border-bottom: 1px solid #333;
      cursor: pointer;
      transition: background 0.2s;
      color: #0af;
      font-size: 1rem;
      font-weight: bold;
    }

    .uploaded-map-item:last-child {
      border-bottom: none;
    }

    .uploaded-map-item:hover {
      background: #1a2330;
    }

    .uploaded-map-item.selected {
      background: #0af;
      color: #000;
    }

    .uploaded-map-name {
      flex: 1;
      margin-right: 0.5rem;
    }

    /* Rename button styling */
    .rename-btn {
      background: none;
      border: none;
      color: #0af;
      cursor: pointer;
      font-size: 0.8rem;
      padding: 2px 4px;
      margin-left: 4px;
      border-radius: 3px;
      transition: background 0.2s;
      vertical-align: middle;
    }

    .rename-btn:hover {
      background: rgba(0, 170, 255, 0.2);
    }

    /* Map content wrapper - exists only to sync rotation between image and canvas */
    .map-content {
      display: inline-block;
      position: relative;
      transition: transform 0.3s ease !important;
    }
    
    /* Map rotation classes - applied to .map-content to rotate both image and canvas together */
    .map-content.rot-90 {
      transform: rotate(90deg) !important;
      transform-origin: center center !important;
      border: 3px dashed #f00 !important; /* DEBUG: show border when rotated */
      background: rgba(0,255,255,0.08) !important; /* DEBUG: show bg when rotated */
    }
    .map-content.rot-180 {
      transform: rotate(180deg) !important;
      transform-origin: center center !important;
      border: 3px dashed #f00 !important; /* DEBUG: show border when rotated */
      background: rgba(0,255,255,0.08) !important; /* DEBUG: show bg when rotated */
    }
    .map-content.rot-270 {
      transform: rotate(270deg) !important;
      transform-origin: center center !important;
      border: 3px dashed #f00 !important; /* DEBUG: show border when rotated */
      background: rgba(0,255,255,0.08) !important; /* DEBUG: show bg when rotated */
    }
  </style>
</head>
<body>
  <div id="rotationWarning" style="
    display: none;
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 50, 50, 0.9);
    color: #fff;
    padding: 0.6rem 1.2rem;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: bold;
    z-index: 9999;
    pointer-events: none;
    user-select: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  ">
    Rotate back to normal to draw.
  </div>
  <div class="container">
    <h1>CODM Map Routes</h1>
    <div class="sidebar">
      <h2>CODM Tactical Maps</h2>
      
      <div class="map-selector">
        <label for="sidebarMapSelect">Select Map:</label>
        <div id="uploadedMapsList" class="uploaded-maps-list">
          <!-- Uploaded maps with rename buttons will be added here -->
        </div>
        <select id="sidebarMapSelect">
          <option value="" disabled selected>Choose a map...</option>
          <!-- Uploaded maps will be inserted here dynamically -->
          <option value="cage">Cage</option>
          <option value="cheshire_park">Cheshire Park</option>
          <option value="coastal">Coastal</option>
          <option value="combine">Combine</option>
          <option value="crash">Crash</option>
          <option value="crossfire">Crossfire</option>
          <option value="diesel">Diesel</option>
          <option value="docks">Docks</option>
          <option value="dome">Dome</option>
          <option value="firing_range">Firing Range</option>
          <option value="hacienda">Hacienda</option>
          <option value="hackney_yard">Hackney Yard</option>
          <option value="hardhat">Hardhat</option>
          <option value="hijacked">Hijacked</option>
          <option value="highrise">Highrise</option>
          <option value="hovec_sawmill">Hovec Sawmill</option>
          <option value="icebreaker">Icebreaker</option>
          <option value="khandor_hideout">Khandor Hideout</option>
          <option value="killhouse">Killhouse</option>
          <option value="king">King</option>
          <option value="kurohana_metropolis">Kurohana Metropolis</option>
          <option value="meltdown">Meltdown</option>
          <option value="monastery">Monastery</option>
          <option value="nuketown">Nuketown</option>
          <option value="nuketown_russia">Nuketown Russia</option>
          <option value="oasis">Oasis</option>
          <option value="pine">Pine</option>
          <option value="raid">Raid</option>
          <option value="rust">Rust</option>
          <option value="saloon">Saloon</option>
          <option value="scrapyard_2019">Scrapyard 2019</option>
          <option value="shipment">Shipment</option>
          <option value="shoot_house">Shoot House</option>
          <option value="slums">Slums</option>
          <option value="standoff">Standoff</option>
          <option value="suldal_harbor">Suldal Harbor</option>
          <option value="summit">Summit</option>
          <option value="takeoff">Takeoff</option>
          <option value="terminal">Terminal</option>
          <option value="tunisia">Tunisia</option>
          <option value="vacant">Vacant</option>
          <option value="zoo">Zoo</option>
        </select>
        <button id="rotateMapBtn" class="upload-btn" style="margin-top:0.7rem;">‚ü≥ Rotate</button>
      </div>

      <div class="upload-section">
        <label for="imageUpload">Upload Custom Map:</label>
        <input type="file" id="imageUpload" accept="image/*" style="display: none;">
        <button id="uploadBtn" class="upload-btn">üìÅ Choose Image</button>
        <div id="uploadStatus" class="upload-status"></div>
      </div>
      <div id="uploadsContainer" style="margin:1rem 0;"></div>

      <div class="whiteboard-controls">
        <div style="margin-bottom:0.7rem;">
          <div style="font-weight:bold;color:#0af;margin-bottom:0.3rem;font-size:0.98rem;">Route Color</div>
          <div id="routeColorButtons" style="display:flex;gap:6px;flex-wrap:wrap;">
            <button class="route-color-btn" data-color="#0af" style="background:#0af;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:2px solid #0af;cursor:pointer;"></button>
            <button class="route-color-btn" data-color="#e53935" style="background:#e53935;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="route-color-btn" data-color="#43a047" style="background:#43a047;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="route-color-btn" data-color="#fbc02d" style="background:#fbc02d;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="route-color-btn" data-color="#ff9800" style="background:#ff9800;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="route-color-btn" data-color="#8e24aa" style="background:#8e24aa;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
          </div>
        </div>
        <!-- Marker Color Buttons -->
        <div style="margin-bottom:0.7rem;">
          <div style="font-weight:bold;color:#0af;margin-bottom:0.3rem;font-size:0.98rem;">Marker Color</div>
          <div id="markerColorButtons" style="display:flex;gap:6px;flex-wrap:wrap;">
            <button class="marker-color-btn" data-color="#0af" style="background:#0af;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:2px solid #0af;cursor:pointer;"></button>
            <button class="marker-color-btn" data-color="#e53935" style="background:#e53935;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="marker-color-btn" data-color="#43a047" style="background:#43a047;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="marker-color-btn" data-color="#fbc02d" style="background:#fbc02d;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="marker-color-btn" data-color="#ff9800" style="background:#ff9800;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
            <button class="marker-color-btn" data-color="#8e24aa" style="background:#8e24aa;width:28px;height:28px;border-radius:50%;border:2px solid #fff;outline:none;cursor:pointer;"></button>
          </div>
        </div>
        <input type="text" id="boardName" placeholder="Enter board name" class="board-input">
        <button id="saveBoardBtn" aria-label="Save current board"><span class="icon">üíæ</span><span class="label"> Save Board</span></button>
        <select id="savedBoards" onchange="loadBoard()" class="board-select">
          <option value="">Select a saved board</option>
        </select>
        <button onclick="resetCanvas()" aria-label="Clear all drawings"><span class="icon">üßπ</span><span class="label"> Clear Board</span></button>
        <button id="undoBtn" aria-label="Undo last drawing"><span class="icon">‚Ü©Ô∏è</span><span class="label"> Undo</span></button>
        <button id="redoBtn" aria-label="Redo last undone drawing"><span class="icon">‚Ü™Ô∏è</span><span class="label"> Redo</span></button>
        <button onclick="exportAsImage()" aria-label="Export board as image"><span class="icon">üì§</span><span class="label"> Export Board</span></button>
        <button onclick="newBoard()" aria-label="Create new board"><span class="icon">üìù</span><span class="label"> New Board</span></button>
        <button onclick="deleteSelectedBoard()" aria-label="Delete selected board"><span class="icon">üóëÔ∏è</span><span class="label"> Delete Board</span></button>
        <button id="sidebarAddMarkerBtn" aria-label="Add marker"><span class="icon">üìç</span><span class="label"> Add Marker</span></button>
        <button id="installBtn" onclick="installApp()" aria-label="Install app" style="display: none;"><span class="icon">üì±</span><span class="label"> Install App</span></button>
        <button id="checkUpdateBtn" aria-label="Check for update" style="background:#0af;color:#fff;"><span class="icon">üîÑ</span><span class="label"> Check for Update</span></button>
      </div>
    </div>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle sidebar">‚ò∞</button>
    <div id="currentMapLabel" style="position:fixed;left:100px;top:1rem;z-index:251;color:#0af;font-weight:bold;font-size:1.05rem;text-shadow:0 1px 4px #000;pointer-events:none;">Standoff</div>
    <div id="offlineIndicator" style="position:fixed;right:1rem;top:1rem;z-index:252;background:#ff4444;color:#fff;padding:0.8rem 1rem;border-radius:8px;font-size:1rem;font-weight:bold;display:none;box-shadow:0 2px 8px rgba(0,0,0,0.3);">Offline</div>
    <div id="installBanner" style="position:fixed;top:0;left:0;right:0;background:#0af;color:#000;padding:1rem;text-align:center;z-index:300;display:none;box-shadow:0 4px 16px rgba(0,0,0,0.3);">
      <span style="font-weight:bold;font-size:1.1rem;">üì± Install CODM Maps for the best experience!</span>
      <button onclick="installApp()" style="margin-left:1rem;background:#000;color:#0af;border:none;padding:0.8rem 1.5rem;border-radius:8px;font-weight:bold;cursor:pointer;font-size:1rem;min-height:44px;">Install Now</button>
      <button onclick="hideInstallBanner()" style="margin-left:0.5rem;background:transparent;color:#000;border:2px solid #000;padding:0.8rem 1.5rem;border-radius:8px;cursor:pointer;font-size:1rem;min-height:44px;">Not Now</button>
    </div>

    <main>
      <div class="map-entry" id="standoff">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="standoffMapImage" src="standoff-clean.png" alt="Standoff Map">
          <canvas id="standoffDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="firing_range">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="firingRangeMapImage" src="firing_range_labeled.png" alt="Firing Range Map">
          <canvas id="firingRangeDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="zoo" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="zooMapImage" src="zoo_labeled.png" alt="Zoo Map">
          <canvas id="zooDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="terminal" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="terminalMapImage" src="terminal_labeled.png" alt="Terminal Map">
          <canvas id="terminalDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="tunisia" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="tunisiaMapImage" src="tunisia_labeled.png" alt="Tunisia Map">
          <canvas id="tunisiaDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="monastery" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="monasteryMapImage" src="monastery.png" alt="Monastery Map">
          <canvas id="monasteryDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="oasis" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="oasisMapImage" src="oasis.png" alt="Oasis Map">
          <canvas id="oasisDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="rust" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="rustMapImage" src="rust.png" alt="Rust Map">
          <canvas id="rustDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="hacienda" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="haciendaMapImage" src="hacienda_labeled.png" alt="Hacienda Map">
          <canvas id="haciendaDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="highrise" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="highriseMapImage" src="highrise.png" alt="Highrise Map">
          <canvas id="highriseDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="icebreaker" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="icebreakerMapImage" src="icebreaker.png" alt="Icebreaker Map">
          <canvas id="icebreakerDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="takeoff" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="takeoffMapImage" src="takeoff.png" alt="Takeoff Map">
          <canvas id="takeoffDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="vacant" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="vacantMapImage" src="vacant.png" alt="Vacant Map">
          <canvas id="vacantDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="hackney_yard" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="hackneyYardMapImage" src="hackney_yard.png" alt="Hackney Yard Map">
          <canvas id="hackneyYardDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="hovec_sawmill" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="hovecSawmillMapImage" src="hovec_sawmill.png" alt="Hovec Sawmill Map">
          <canvas id="hovecSawmillDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="shipment" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="shipmentMapImage" src="shipment.png" alt="Shipment Map">
          <canvas id="shipmentDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="scrapyard_2019" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="scrapyard2019MapImage" src="scrapyard_2019.png" alt="Scrapyard 2019 Map">
          <canvas id="scrapyard2019DrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="suldal_harbor" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="suldalHarborMapImage" src="suldal_harbor.png" alt="Suldal Harbor Map">
          <canvas id="suldalHarborDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="dome" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="domeMapImage" src="dome.png" alt="Dome Map">
          <canvas id="domeDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="slums" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="slumsMapImage" src="slums_labeled.png" alt="Slums Map">
          <canvas id="slumsDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="nuketown_russia" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="nuketownRussiaMapImage" src="nuketown_russia.png" alt="Nuketown Russia Map">
          <canvas id="nuketownRussiaDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="meltdown" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="meltdownMapImage" src="meltdown.png" alt="Meltdown Map">
          <canvas id="meltdownDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="summit" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="summitMapImage" src="summit.png" alt="Summit Map">
          <canvas id="summitDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="hijacked" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="hijackedMapImage" src="hijacked.png" alt="Hijacked Map">
          <canvas id="hijackedDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="crash" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="crashMapImage" src="crash_labeled.png" alt="Crash Map">
          <canvas id="crashDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="crossfire" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="crossfireMapImage" src="crossfire.png" alt="Crossfire Map">
          <canvas id="crossfireDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="raid" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="raidMapImage" src="raid_labeled.png" alt="Raid Map">
          <canvas id="raidDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="nuketown" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="nuketownMapImage" src="nuketown.png" alt="Nuketown Map">
          <canvas id="nuketownDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="killhouse" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="killhouseMapImage" src="killhouse.png" alt="Killhouse Map">
          <canvas id="killhouseDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="hardhat" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="hardhatMapImage" src="hardhat.png" alt="Hardhat Map">
          <canvas id="hardhatDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="saloon" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="saloonMapImage" src="saloon.png" alt="Saloon Map">
          <canvas id="saloonDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="pine" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="pineMapImage" src="pine.png" alt="Pine Map">
          <canvas id="pineDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="king" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="kingMapImage" src="king.png" alt="King Map">
          <canvas id="kingDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="docks" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="docksMapImage" src="docks.png" alt="Docks Map">
          <canvas id="docksDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="shoot_house" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="shootHouseMapImage" src="shoot_house.png" alt="Shoot House Map">
          <canvas id="shootHouseDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="cage" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
          <img id="cageMapImage" src="cage.png" alt="Cage Map">
          <canvas id="cageDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="coastal" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="coastalMapImage" src="coastal_labeled.png" alt="Coastal Map">
            <canvas id="coastalDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="diesel" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="dieselMapImage" src="diesel_labeled.png" alt="Diesel Map">
            <canvas id="dieselDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="kurohana_metropolis" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="kurohanaMetropolisMapImage" src="kurohana_metropolis_labeled.png" alt="Kurohana Metropolis Map">
            <canvas id="kurohanaMetropolisDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="combine" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="combineMapImage" src="combine_labeled.png" alt="Combine Map">
            <canvas id="combineDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="cheshire_park" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="cheshireParkMapImage" src="cheshire_park_labeled.png" alt="Cheshire Park Map">
            <canvas id="cheshireParkDrawingCanvas"></canvas>
          </div>
        </div>
      </div>

      <div class="map-entry" id="khandor_hideout" style="display:none;">
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="khandorHideoutMapImage" src="khandor_hideout_labeled.png" alt="Khandor Hideout Map">
            <canvas id="khandorHideoutDrawingCanvas"></canvas>
          </div>
        </div>
      </div>
    </main>

    <!-- Floating Action Button for mobile -->
    <div class="fab" id="fab">
      <button class="fab-main" id="fabMainBtn" aria-label="Open actions" tabindex="0" aria-expanded="false">Ôºã</button>
      <div class="fab-menu" id="fabMenu">
        <button class="fab-action" id="fabAddMarker">üìç Add Marker</button>
        <button class="fab-action" id="fabSaveBoard">üíæ Save Board</button>
        <button class="fab-action" id="fabExportBoard">üì§ Export Board</button>
        <button class="fab-action" id="fabClearBoard">üßπ Clear Board</button>
        <button class="fab-action" id="fabUndo">‚Ü©Ô∏è Undo</button>
        <button class="fab-action" id="fabRedo">‚Ü™Ô∏è Redo</button>
        <button class="fab-action" id="fabInstall" style="display: none;">üì± Install App</button>
      </div>
    </div>

    <footer>
      <p>Fan-made. Not affiliated with Activision. All rights belong to their respective owners.</p>
    </footer>
  </div>

  <!-- Add update button to the page (hidden by default) -->
  <button id="update-btn" style="display:none;position:fixed;top:10px;right:10px;z-index:9999;background:#0af;color:#fff;font-weight:bold;padding:1rem 2rem;border:none;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.2);cursor:pointer;">Update Available - Click to Refresh</button>

  <script>

    <!-- Hello, World temp -->
    alert("Hello, World!")

    // Global variables
    let canvas, ctx, mapImg;
    let isDrawing = false;
    let currentDrawing = null;
    let markers = [];
    let currentMap = 'cage';
    let deferredPrompt;
    // Color state
    let currentRouteColor = '#0af';
    let currentMarkerColor = '#0af';
    
    // Upload functionality
    let uploadedMaps = {};
    let uploadCounter = 0;
    
    // Persistent storage functions
    function saveUploadedMaps() {
      try {
        const dataToSave = {
          uploadedMaps: uploadedMaps,
          uploadCounter: uploadCounter,
          // Save drawings and markers for uploaded maps
          uploadedMapDrawings: {},
          uploadedMapMarkers: {}
        };
        
        // Save drawings and markers for each uploaded map
        Object.keys(uploadedMaps).forEach(mapId => {
          if (mapDrawings[mapId]) {
            dataToSave.uploadedMapDrawings[mapId] = mapDrawings[mapId];
          }
          if (mapMarkers[mapId]) {
            dataToSave.uploadedMapMarkers[mapId] = mapMarkers[mapId];
          }
        });
        
        localStorage.setItem('uploadedMapsData', JSON.stringify(dataToSave));
        console.log('Uploaded maps saved successfully');
      } catch (error) {
        console.error('Error saving uploaded maps:', error);
      }
    }
    
    function loadUploadedMaps() {
      try {
        const savedData = localStorage.getItem('uploadedMapsData');
        if (savedData) {
          const data = JSON.parse(savedData);
          uploadedMaps = data.uploadedMaps || {};
          uploadCounter = data.uploadCounter || 0;
          
          // Restore drawings and markers for uploaded maps
          if (data.uploadedMapDrawings) {
            Object.keys(data.uploadedMapDrawings).forEach(mapId => {
              mapDrawings[mapId] = data.uploadedMapDrawings[mapId];
            });
          }
          if (data.uploadedMapMarkers) {
            Object.keys(data.uploadedMapMarkers).forEach(mapId => {
              mapMarkers[mapId] = data.uploadedMapMarkers[mapId];
            });
          }
          
          // Recreate map entries and add to selector
          Object.keys(uploadedMaps).forEach(mapId => {
            recreateUploadedMap(mapId, uploadedMaps[mapId]);
          });
          
          console.log('Uploaded maps loaded successfully');
        }
      } catch (error) {
        console.error('Error loading uploaded maps:', error);
        // Clear corrupted data
        localStorage.removeItem('uploadedMapsData');
      }
    }
    
    function recreateUploadedMap(mapId, mapData) {
      // Create map entry HTML
      const mapEntry = document.createElement('div');
      mapEntry.className = 'map-entry';
      mapEntry.id = mapId;
      mapEntry.style.display = 'none';
      
      mapEntry.innerHTML = `
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="${mapId}MapImage" src="${mapData.base64}" alt="${mapData.name} Map">
            <canvas id="${mapId}DrawingCanvas"></canvas>
          </div>
        </div>
      `;
      
      // Add to main content
      document.querySelector('main').appendChild(mapEntry);
      
      // Add to custom uploaded maps list
      addToUploadedMapsList(mapId, mapData.name);
      
      // Setup canvas for the restored map with improved timing
      const canvas = document.getElementById(`${mapId}DrawingCanvas`);
      if (canvas) {
        setupCanvas(canvas);
        // Additional delay for restored uploaded maps to ensure proper rendering
        requestAnimationFrame(() => {
          setTimeout(() => {
            const mapImg = document.getElementById(`${mapId}MapImage`);
            if (mapImg && mapImg.complete) {
              // Trigger a single resize for the restored map
              const canvas = document.getElementById(`${mapId}DrawingCanvas`);
              if (canvas && canvas.dataset.resized !== 'true') {
                // Direct resize call with debouncing
                if (canvas.resizeTimeout) {
                  clearTimeout(canvas.resizeTimeout);
                }
                canvas.resizeTimeout = setTimeout(() => {
                  if (canvas.dataset.resized !== 'true') {
                    canvas.dataset.resized = 'true';
                    const parent = canvas.parentElement;
                    const img = parent.querySelector('img');
                    if (img && img.complete && img.naturalWidth > 0) {
                      const rect = img.getBoundingClientRect();
                      const width = Math.round(rect.width);
                      const height = Math.round(rect.height);
                      if (width > 0 && height > 0) {
                        canvas.width = width;
                        canvas.height = height;
                        canvas.style.width = width + 'px';
                        canvas.style.height = height + 'px';
                        canvas.style.left = '0px';
                        canvas.style.top = '0px';
                        redraw();
                      }
                    }
                    setTimeout(() => {
                      canvas.dataset.resized = 'false';
                    }, 100);
                  }
                }, 50);
              }
            }
          }, 100);
        });
      }
    }

    // PWA Installation
    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent Chrome 67 and earlier from automatically showing the prompt
      e.preventDefault();
      // Stash the event so it can be triggered later
      deferredPrompt = e;
      // Show install button if it exists
      showInstallButton();
    });

    function showInstallButton() {
      // Show install button in sidebar
      const installBtn = document.getElementById('installBtn');
      if (installBtn) {
        installBtn.style.display = 'block';
      }
      
      // Show install button in FAB menu for mobile
      const fabInstallBtn = document.getElementById('fabInstall');
      if (fabInstallBtn) {
        fabInstallBtn.style.display = 'block';
      }
    }

    function hideInstallBanner() {
      const installBanner = document.getElementById('installBanner');
      if (installBanner) {
        installBanner.style.display = 'none';
      }
    }

    function installApp() {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then((choiceResult) => {
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted the install prompt');
            hideInstallBanner();
          } else {
            console.log('User dismissed the install prompt');
          }
          deferredPrompt = null;
        });
      }
    }

    // Register service worker for PWA features (make sure sw.js is in the project root)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        const isLocalhost = ['localhost', '127.0.0.1'].includes(location.hostname);
        
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration);
            // Prompt user to reload when a new SW is available (only on production)
            if (!isLocalhost) {
            registration.onupdatefound = () => {
              const newWorker = registration.installing;
              newWorker.onstatechange = () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  if (confirm('A new version is available. Reload now?')) {
                    window.location.reload();
                  }
                }
              };
            };
            }
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }

    // Handle app installed event
    window.addEventListener('appinstalled', (evt) => {
      console.log('App was installed');
    });

    // Handle online/offline status
    window.addEventListener('online', () => {
      const indicator = document.getElementById('offlineIndicator');
      if (indicator) {
        indicator.style.display = 'none';
      }
    });

    window.addEventListener('offline', () => {
      const indicator = document.getElementById('offlineIndicator');
      if (indicator) {
        indicator.style.display = 'block';
      }
    });

    // Drawing state per map
    const mapDrawings = {
      standoff: { drawings: [], undone: [] },
      firing_range: { drawings: [], undone: [] },
      zoo: { drawings: [], undone: [] },
      terminal: { drawings: [], undone: [] },
      tunisia: { drawings: [], undone: [] },
      monastery: { drawings: [], undone: [] },
      oasis: { drawings: [], undone: [] },
      rust: { drawings: [], undone: [] },
      hacienda: { drawings: [], undone: [] },
      highrise: { drawings: [], undone: [] },
      icebreaker: { drawings: [], undone: [] },
      takeoff: { drawings: [], undone: [] },
      vacant: { drawings: [], undone: [] },
      hackney_yard: { drawings: [], undone: [] },
      hovec_sawmill: { drawings: [], undone: [] },
      shipment: { drawings: [], undone: [] },
      scrapyard_2019: { drawings: [], undone: [] },
      suldal_harbor: { drawings: [], undone: [] },
      dome: { drawings: [], undone: [] },
      slums: { drawings: [], undone: [] },
      nuketown_russia: { drawings: [], undone: [] },
      meltdown: { drawings: [], undone: [] },
      summit: { drawings: [], undone: [] },
      hijacked: { drawings: [], undone: [] },
      crash: { drawings: [], undone: [] },
      crossfire: { drawings: [], undone: [] },
      raid: { drawings: [], undone: [] },
      nuketown: { drawings: [], undone: [] },
      killhouse: { drawings: [], undone: [] },
      hardhat: { drawings: [], undone: [] },
      saloon: { drawings: [], undone: [] },
      pine: { drawings: [], undone: [] },
      king: { drawings: [], undone: [] },
      docks: { drawings: [], undone: [] },
      shoot_house: { drawings: [], undone: [] },
      cage: { drawings: [], undone: [] },
      coastal: { drawings: [], undone: [] },
      diesel: { drawings: [], undone: [] },
      kurohana_metropolis: { drawings: [], undone: [] },
      combine: { drawings: [], undone: [] },
      cheshire_park: { drawings: [], undone: [] },
      khandor_hideout: { drawings: [], undone: [] }
    };

    // Markers state per map
    const mapMarkers = {
      standoff: [],
      firing_range: [],
      zoo: [],
      terminal: [],
      tunisia: [],
      monastery: [],
      oasis: [],
      rust: [],
      hacienda: [],
      highrise: [],
      icebreaker: [],
      takeoff: [],
      vacant: [],
      hackney_yard: [],
      hovec_sawmill: [],
      shipment: [],
      scrapyard_2019: [],
      suldal_harbor: [],
      dome: [],
      slums: [],
      nuketown_russia: [],
      meltdown: [],
      summit: [],
      hijacked: [],
      crash: [],
      crossfire: [],
      raid: [],
      nuketown: [],
      killhouse: [],
      hardhat: [],
      saloon: [],
      pine: [],
      king: [],
      docks: [],
      shoot_house: [],
      cage: [],
      coastal: [],
      diesel: [],
      kurohana_metropolis: [],
      combine: [],
      cheshire_park: [],
      khandor_hideout: []
    };

    // Helper to get current map's drawing state
    function getCurrentDrawingState() {
      return mapDrawings[currentMap];
    }

    // Helper to get current map's markers array
    function getCurrentMarkers() {
      return mapMarkers[currentMap];
    }

    // Save board function
    function saveBoard() {
      const boardName = document.getElementById('boardName').value;
      if (!boardName) {
        alert('Please enter a board name');
        return;
      }
      const activeMap = document.querySelector('.map-entry:not([style*="display: none"])');
      const mapId = activeMap.id;
      const boardData = {
        mapId: mapId,
        drawings: getCurrentDrawingState().drawings,
        markers: mapMarkers[mapId]
      };
      const savedBoards = JSON.parse(localStorage.getItem('savedBoards') || '{}');
      savedBoards[boardName] = boardData;
      localStorage.setItem('savedBoards', JSON.stringify(savedBoards));
      document.getElementById('boardName').value = '';
      updateBoardList();
    }

    // Redraw function for the active canvas
    function redraw() {
      const canvas = getActiveCanvas();
      if (!canvas) return;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const { drawings } = getCurrentDrawingState();
      drawings.forEach(route => {
        // Support old format (array of points) and new format ({color, path})
        let color = '#0af';
        let path = route;
        if (route && route.path && Array.isArray(route.path)) {
          color = route.color || '#0af';
          path = route.path;
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        if (path.length > 0) {
          ctx.beginPath();
          ctx.moveTo(path[0].x, path[0].y);
          for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
          }
          ctx.stroke();
        }
      });
      // Draw bomb sites and spawns overlays
      drawSitesAndSpawns();
    }

    // Drawing event handlers
    let path = [];
    let drawingColor = currentRouteColor;
    
    // Helper function to check if drawing is allowed (rotation must be 0 degrees)
    function isDrawingAllowed() {
      // Find the currently visible map entry
      let visibleMapEntry = null;
      const allMapEntries = document.querySelectorAll('.map-entry');
      
      for (const entry of allMapEntries) {
        if (entry.style.display !== 'none' && entry.offsetParent !== null) {
          visibleMapEntry = entry;
          break;
        }
      }
      
      if (!visibleMapEntry) {
        return false;
      }
      
      // Check if the map content has rotation at 0 degrees
      const mapContent = visibleMapEntry.querySelector('.map-content');
      if (!mapContent) {
        return false;
      }
      
      const rotation = parseInt(mapContent.getAttribute('data-rot') || '0', 10);
      return rotation === 0;
    }
    
    // Helper function to show rotation warning
    function showRotationWarning() {
      const warning = document.getElementById("rotationWarning");
      if (!warning) return;
      warning.style.display = "block";
      clearTimeout(warning._timeout);
      warning._timeout = setTimeout(() => {
        warning.style.display = "none";
      }, 3000);
    }
    
    function startDrawing(e) {
      // Check if drawing is allowed (rotation must be 0 degrees)
      if (!isDrawingAllowed()) {
        showRotationWarning();
        return;
      }
      
      isDrawing = true;
      const canvas = e.target;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      // Capture the color at the start of drawing
      drawingColor = currentRouteColor;
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches && e.touches.length > 0) {
        x = (e.touches[0].clientX - rect.left) * (canvas.offsetWidth / rect.width);
        y = (e.touches[0].clientY - rect.top) * (canvas.offsetHeight / rect.height);
      } else {
        x = (e.clientX - rect.left) * (canvas.offsetWidth / rect.width);
        y = (e.clientY - rect.top) * (canvas.offsetHeight / rect.height);
      }
      path = [{ x, y }];
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    function draw(e) {
      if (!isDrawing) return;
      
      // Check if drawing is still allowed (rotation must be 0 degrees)
      if (!isDrawingAllowed()) {
        showRotationWarning();
        isDrawing = false;
        return;
      }
      
      const canvas = e.target;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.strokeStyle = drawingColor;
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches && e.touches.length > 0) {
        x = (e.touches[0].clientX - rect.left) * (canvas.offsetWidth / rect.width);
        y = (e.touches[0].clientY - rect.top) * (canvas.offsetHeight / rect.height);
      } else {
        x = (e.clientX - rect.left) * (canvas.offsetWidth / rect.width);
        y = (e.clientY - rect.top) * (canvas.offsetHeight / rect.height);
      }
      path.push({ x, y });
      ctx.lineWidth = 2;
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    function stopDrawing(e) {
      if (!isDrawing) return;
      isDrawing = false;
      if (path.length > 1) {
        const { drawings, undone } = getCurrentDrawingState();
        // Store as { color, path } using the color at draw start
        drawings.push({ color: drawingColor, path: [...path] });
        undone.length = 0; // Clear redo stack
        
        // Auto-save uploaded map data
        if (currentMap.startsWith('uploaded_')) {
          saveUploadedMaps();
        }
      }
      redraw();
    }

    // Undo/Redo functions
    function undoDrawing() {
      const { drawings, undone } = getCurrentDrawingState();
      if (drawings.length > 0) {
        undone.push(drawings.pop());
        redraw();
      }
    }
    function redoDrawing() {
      const { drawings, undone } = getCurrentDrawingState();
      if (undone.length > 0) {
        drawings.push(undone.pop());
        redraw();
      }
    }

    // Wire up Undo/Redo buttons
    window.onload = function() {
        // Hide all maps initially
        document.querySelectorAll('.map-entry').forEach(entry => {
            entry.style.display = 'none';
        });
        // Find the first real map option (skip placeholder)
        const mapSelector = document.getElementById('sidebarMapSelect');
        let firstMapValue = '';
        if (mapSelector) {
            for (let i = 0; i < mapSelector.options.length; i++) {
                const opt = mapSelector.options[i];
                if (opt.value && !opt.disabled) {
                    firstMapValue = opt.value;
                    mapSelector.value = firstMapValue;
                    break;
                }
            }
        }
        if (firstMapValue) {
            currentMap = firstMapValue;
            const firstMapDiv = document.getElementById(firstMapValue);
            if (firstMapDiv) {
                firstMapDiv.style.display = 'block';
            }
            // Set the current map label
            const mapLabel = document.getElementById('currentMapLabel');
            if (mapLabel) {
                // Use the option's text as the label
                const selectedOption = mapSelector.querySelector(`option[value="${firstMapValue}"]`);
                mapLabel.textContent = selectedOption ? selectedOption.textContent : firstMapValue;
            }
            mapSelector.addEventListener('change', function() {
                switchMap(this.value);
            });
        }
        // Set up save button
        const saveButton = document.getElementById('saveBoardBtn');
        if (saveButton) {
            saveButton.addEventListener('click', saveBoard);
        }
            // Wire up Undo/Redo buttons
    document.getElementById('undoBtn').onclick = undoDrawing;
    document.getElementById('redoBtn').onclick = redoDrawing;
    // Load saved boards
    updateBoardList();
        
        // Load uploaded maps from localStorage
        loadUploadedMaps();
        
        // Setup all canvases
        const allCanvases = document.querySelectorAll('canvas[id$="DrawingCanvas"]');
        allCanvases.forEach(canvas => {
          setupCanvas(canvas);
        });
        
        // Setup upload functionality
        const uploadBtn = document.getElementById('uploadBtn');
        const imageUpload = document.getElementById('imageUpload');
        
        if (uploadBtn && imageUpload) {
          uploadBtn.addEventListener('click', () => {
            imageUpload.click();
          });
          
          imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
              if (file.type.startsWith('image/')) {
                handleImageUpload(file);
              } else {
                const statusDiv = document.getElementById('uploadStatus');
                statusDiv.textContent = 'Please select an image file.';
                statusDiv.className = 'upload-status error';
              }
            }
          });
        }
    
    // Handle URL parameters for PWA shortcuts
    const urlParams = new URLSearchParams(window.location.search);
    const mapParam = urlParams.get('map');
    if (mapParam && mapParam !== 'standoff') {
      // Switch to the specified map
      setTimeout(() => {
        switchMap(mapParam);
        // Update the select dropdown
        const mapSelect = document.getElementById('sidebarMapSelect');
        if (mapSelect) {
          mapSelect.value = mapParam;
        }
      }, 100);
    }
    };

    function setupCanvas(canvas) {
        if (!canvas) return;
        
        function attachEventListeners() {
          // Remove existing listeners to prevent duplicates
          canvas.removeEventListener('mousedown', startDrawing);
          canvas.removeEventListener('mousemove', draw);
          canvas.removeEventListener('mouseup', stopDrawing);
          canvas.removeEventListener('mouseout', stopDrawing);
          canvas.removeEventListener('touchstart', handleTouchStart);
          canvas.removeEventListener('touchmove', handleTouchMove);
          canvas.removeEventListener('touchend', handleTouchEnd);
          canvas.removeEventListener('touchcancel', handleTouchEnd);
          // Add event listeners
          canvas.addEventListener('mousedown', startDrawing);
          canvas.addEventListener('mousemove', draw);
          canvas.addEventListener('mouseup', stopDrawing);
          canvas.addEventListener('mouseout', stopDrawing);
          canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
          canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
          canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
          canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        }
        
        // Debounce timeout for resize operations
        let resizeTimeout = null;
        
        function resizeCanvas() {
          // Prevent multiple resize calls for the same canvas
          if (canvas.dataset.resized === 'true') {
            return;
          }
          
          const parent = canvas.parentElement;
          const mapImg = parent.querySelector('img');
          if (mapImg && mapImg.complete && mapImg.naturalWidth > 0) {
            const mapRect = mapImg.getBoundingClientRect();
            const width = Math.round(mapRect.width);
            const height = Math.round(mapRect.height);
            if (width === 0 || height === 0) return; // Skip if not visible
            
            // Set flag to prevent multiple resizes
            canvas.dataset.resized = 'true';
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.left = '0px';
            canvas.style.top = '0px';
            attachEventListeners();
            redraw();
            
            // Reset flag after a short delay to allow future resizes if needed
            setTimeout(() => {
              canvas.dataset.resized = 'false';
            }, 100);
          }
        }
        
        // Debounced resize function
        function debouncedResizeCanvas() {
          if (resizeTimeout) {
            clearTimeout(resizeTimeout);
          }
          resizeTimeout = setTimeout(resizeCanvas, 50);
        }
        
        // Enhanced resize function with requestAnimationFrame and debouncing
        function resizeCanvasWithDelay() {
          requestAnimationFrame(() => {
            debouncedResizeCanvas();
          });
        }
        
        // Wait for image to load before initial resize
        const mapImg = canvas.parentElement.querySelector('img');
        if (mapImg) {
          if (mapImg.complete && mapImg.naturalWidth > 0) {
            // For preloaded maps, use immediate resize
            resizeCanvas();
          } else {
            // For uploaded maps, use delayed resize to ensure proper rendering
            mapImg.onload = function() {
              resizeCanvasWithDelay();
            };
          }
        }
        
        window.addEventListener('resize', debouncedResizeCanvas);
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.strokeStyle = '#0af';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        attachEventListeners();
    }
    
    // Touch event handlers
    function handleTouchStart(e) {
      e.preventDefault();
      startDrawing(e);
    }
    
    function handleTouchMove(e) {
      e.preventDefault();
      draw(e);
    }
    
    function handleTouchEnd(e) {
      e.preventDefault();
      stopDrawing(e);
    }

    // Update resetCanvas to clear drawings and markers for current map
    window.resetCanvas = function() {
      const canvas = getActiveCanvas();
      if (canvas) {
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      document.querySelectorAll('.text-marker').forEach(m => m.remove());
      mapMarkers[currentMap] = [];
      const { drawings, undone } = getCurrentDrawingState();
      drawings.length = 0;
      undone.length = 0;
    };

    // Update switchMap to redraw on map change
    function switchMap(mapId) {
      // Hide all maps
      document.querySelectorAll('.map-entry').forEach(entry => {
        entry.style.display = 'none';
      });
      // Show selected map
      const selectedMap = document.getElementById(mapId);
      if (selectedMap) {
        selectedMap.style.display = 'block';
      }
      // Update current map
      currentMap = mapId;
      
      // Update selected state in custom uploaded maps list
      if (mapId.startsWith('uploaded_')) {
        updateSelectedMapItem(mapId);
      }
      
      // Resize canvas for the newly active map
      setTimeout(() => {
        const activeCanvas = getActiveCanvas();
        if (activeCanvas) {
          // Use debounced resize instead of forcing resize events
          if (activeCanvas.dataset.resized !== 'true') {
            debouncedResizeCanvas();
          }
          
          // Additional delay for uploaded maps to ensure proper rendering
          if (mapId.startsWith('uploaded_')) {
            requestAnimationFrame(() => {
              setTimeout(() => {
                const mapImg = activeCanvas.parentElement.querySelector('img');
                if (mapImg && mapImg.complete && activeCanvas.dataset.resized !== 'true') {
                  // Use debounced resize for uploaded maps
                  debouncedResizeCanvas();
                }
              }, 50);
            });
          }
          
          // Ensure drawing is ready
          setTimeout(() => {
            const ctx = activeCanvas.getContext('2d', { willReadFrequently: true });
            ctx.strokeStyle = '#0af';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
          }, 50);
        }
      }, 100);
      
      redraw();
      // Update map label
      var mapLabel = document.getElementById('currentMapLabel');
      if (mapLabel) {
        if (mapId === 'standoff') mapLabel.textContent = 'Standoff';
        else if (mapId === 'firing_range') mapLabel.textContent = 'Firing Range';
        else if (mapId === 'zoo') mapLabel.textContent = 'Zoo';
        else if (mapId === 'terminal') mapLabel.textContent = 'Terminal';
        else if (mapId === 'tunisia') mapLabel.textContent = 'Tunisia';
        else if (mapId === 'monastery') mapLabel.textContent = 'Monastery';
        else if (mapId === 'oasis') mapLabel.textContent = 'Oasis';
        else if (mapId === 'rust') mapLabel.textContent = 'Rust';
        else if (mapId === 'hacienda') mapLabel.textContent = 'Hacienda';
        else if (mapId === 'highrise') mapLabel.textContent = 'Highrise';
        else if (mapId === 'icebreaker') mapLabel.textContent = 'Icebreaker';
        else if (mapId === 'takeoff') mapLabel.textContent = 'Takeoff';
        else if (mapId === 'vacant') mapLabel.textContent = 'Vacant';
        else if (mapId === 'hackney_yard') mapLabel.textContent = 'Hackney Yard';
        else if (mapId === 'hovec_sawmill') mapLabel.textContent = 'Hovec Sawmill';
        else if (mapId === 'shipment') mapLabel.textContent = 'Shipment';
        else if (mapId === 'scrapyard_2019') mapLabel.textContent = 'Scrapyard 2019';
        else if (mapId === 'suldal_harbor') mapLabel.textContent = 'Suldal Harbor';
        else if (mapId === 'dome') mapLabel.textContent = 'Dome';
        else if (mapId === 'slums') mapLabel.textContent = 'Slums';
        else if (mapId === 'nuketown_russia') mapLabel.textContent = 'Nuketown Russia';
        else if (mapId === 'meltdown') mapLabel.textContent = 'Meltdown';
        else if (mapId === 'summit') mapLabel.textContent = 'Summit';
        else if (mapId === 'hijacked') mapLabel.textContent = 'Hijacked';
        else if (mapId === 'crash') mapLabel.textContent = 'Crash';
        else if (mapId === 'crossfire') mapLabel.textContent = 'Crossfire';
        else if (mapId === 'raid') mapLabel.textContent = 'Raid';
        else if (mapId === 'nuketown') mapLabel.textContent = 'Nuketown';
        else if (mapId === 'killhouse') mapLabel.textContent = 'Killhouse';
        else if (mapId === 'hardhat') mapLabel.textContent = 'Hardhat';
        else if (mapId === 'saloon') mapLabel.textContent = 'Saloon';
        else if (mapId === 'pine') mapLabel.textContent = 'Pine';
        else if (mapId === 'king') mapLabel.textContent = 'King';
        else if (mapId === 'docks') mapLabel.textContent = 'Docks';
        else if (mapId === 'shoot_house') mapLabel.textContent = 'Shoot House';
        else if (mapId === 'cage') mapLabel.textContent = 'Cage';
        else if (mapId === 'coastal') mapLabel.textContent = 'Coastal';
        else if (mapId === 'diesel') mapLabel.textContent = 'Diesel';
        else if (mapId === 'kurohana_metropolis') mapLabel.textContent = 'Kurohana Metropolis';
        else if (mapId === 'combine') mapLabel.textContent = 'Combine';
        else if (mapId === 'cheshire_park') mapLabel.textContent = 'Cheshire Park';
        else if (mapId === 'khandor_hideout') mapLabel.textContent = 'Khandor Hideout';
        else mapLabel.textContent = '';
      }
    }

    // Export function
    function exportAsImage() {
      // Always get the currently visible map's canvas and image
      const canvas = getActiveCanvas();
      const mapImg = getActiveMapImg();
      if (!canvas || !mapImg) {
        console.error('Canvas or map image not found');
        return;
      }
      
      // Create a temporary canvas for export
      const exportCanvas = document.createElement('canvas');
      const exportCtx = exportCanvas.getContext('2d');
      
      // Use canvas dimensions (which now match the map image's aspect ratio)
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      exportCanvas.width = canvasWidth;
      exportCanvas.height = canvasHeight;
      
      // Draw the map image at canvas size
      exportCtx.drawImage(mapImg, 0, 0, canvasWidth, canvasHeight);
      
      // Draw the routes using stored coordinates and colors
      const { drawings } = getCurrentDrawingState();
      drawings.forEach(route => {
        let color = '#0af';
        let path = route;
        if (route && route.path && Array.isArray(route.path)) {
          color = route.color || '#0af';
          path = route.path;
        }
        exportCtx.strokeStyle = color;
        exportCtx.lineWidth = 2;
        exportCtx.lineCap = 'round';
        if (path.length > 0) {
          exportCtx.beginPath();
          exportCtx.moveTo(path[0].x, path[0].y);
          for (let i = 1; i < path.length; i++) {
            exportCtx.lineTo(path[i].x, path[i].y);
          }
          exportCtx.stroke();
        }
      });
      
      // Draw markers
      const markers = getCurrentMarkers();
      markers.forEach(markerData => {
        // Calculate pixel position using canvas dimensions
        const x = markerData.x * canvasWidth;
        const y = markerData.y * canvasHeight;
        // Draw marker background
        exportCtx.save();
        exportCtx.font = 'bold 18px Arial';
        exportCtx.textAlign = 'center';
        exportCtx.textBaseline = 'middle';
        exportCtx.fillStyle = markerData.color || 'rgba(0,0,0,0.8)';
        const text = markerData.text || '';
        const padding = 10;
        const metrics = exportCtx.measureText(text);
        const textWidth = metrics.width;
        const textHeight = 24;
        exportCtx.beginPath();
        exportCtx.roundRect(x - textWidth/2 - padding/2, y - textHeight/2, textWidth + padding, textHeight, 6);
        exportCtx.fill();
        // Draw marker text
        exportCtx.fillStyle = '#fff';
        exportCtx.fillText(text, x, y);
        exportCtx.restore();
      });
      
      // Export as PNG
      const link = document.createElement('a');
      link.download = 'codm_board.png';
      link.href = exportCanvas.toDataURL('image/png');
      link.click();
    }

    // Global functions
    window.deleteSelectedBoard = function() {
      const name = document.getElementById('savedBoards').value;
      if (!name || !confirm('Delete board: ' + name + '?')) return;
      
      // Remove the board from the savedBoards object
      const savedBoards = JSON.parse(localStorage.getItem('savedBoards') || '{}');
      delete savedBoards[name];
      localStorage.setItem('savedBoards', JSON.stringify(savedBoards));
      
      updateBoardList();
      resetCanvas();
      document.getElementById('currentMapLabel').textContent = 'Standoff';
    };

    window.newBoard = function() {
      resetCanvas();
      document.getElementById('currentMapLabel').textContent = 'Standoff';
      document.getElementById('savedBoards').value = '';
    };

    // Add these functions to handle the new buttons
    function addMarkerGlobal() {
      // Check if drawing is allowed (rotation must be 0 degrees)
      if (!isDrawingAllowed()) {
        showRotationWarning();
        return;
      }
      
      const canvas = getActiveCanvas();
      const mapContainer = canvas ? canvas.parentElement : null;
      if (!canvas || !mapContainer) return;
      const text = prompt('Enter marker text:', 'New Marker');
      if (!text) return;
      // Default to center
      const x = 0.5;
      const y = 0.5;
      // Always use the global currentMarkerColor
      const color = currentMarkerColor;
      const marker = createMarker(text, x, y, false, color);
      mapContainer.appendChild(marker);
      getCurrentMarkers().push({ text, x, y, color });
      
      // Auto-save uploaded map data
      if (currentMap.startsWith('uploaded_')) {
        saveUploadedMaps();
      }
    }

    // Refactor sidebar button handlers to always use the active map/canvas/markers
    function getActiveCanvas() {
      const activeMap = document.getElementById(currentMap);
      return activeMap ? activeMap.querySelector('canvas') : null;
    }
    function getActiveMapImg() {
      const activeMap = document.getElementById(currentMap);
      return activeMap ? activeMap.querySelector('img') : null;
    }
    function getActiveMarkers() {
      return markers;
    }

    // Board management functions
    function updateBoardList() {
      const savedBoards = JSON.parse(localStorage.getItem('savedBoards') || '{}');
      const select = document.getElementById('savedBoards');
      select.innerHTML = '<option value="">Select a saved board</option>';
      
      Object.keys(savedBoards).forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      });
    }

    window.loadBoard = function() {
      const boardName = document.getElementById('savedBoards').value;
      if (!boardName) return;
      const savedBoards = JSON.parse(localStorage.getItem('savedBoards') || '{}');
      const boardData = savedBoards[boardName];
      if (!boardData) return;
      
      // Switch to the correct map
      switchMap(boardData.mapId);
      
      // Restore drawings
      if (boardData.drawings) {
        const { drawings, undone } = getCurrentDrawingState();
        drawings.length = 0; // Clear current drawings
        undone.length = 0;   // Clear undo stack
        drawings.push(...boardData.drawings); // Restore saved drawings
        redraw(); // Redraw the canvas
      }
      
      // Restore markers
      mapMarkers[boardData.mapId] = boardData.markers || [];
      updateMarkers();
    };

    // Update updateMarkers to use per-map markers
    function updateMarkers() {
      document.querySelectorAll('.text-marker').forEach(m => m.remove());
      const activeMap = document.querySelector('.map-entry:not([style*="display: none"]) .map-container');
      if (!activeMap) return;
      const markers = getCurrentMarkers();
      markers.forEach(markerData => {
        const marker = createMarker(markerData.text, markerData.x, markerData.y, true, markerData.color);
        activeMap.appendChild(marker);
      });
    }

    // Improved createMarker function with color support
    function createMarker(text, x, y, isRestoring, color) {
      const marker = document.createElement('div');
      marker.className = 'text-marker';
      marker.textContent = text;
      marker.style.left = (x * 100) + '%';
      marker.style.top = (y * 100) + '%';
      marker.draggable = true;
      marker.tabIndex = 0;
      marker.setAttribute('aria-label', `Tactical marker: ${text}`);
      // Set marker background color
      const markerColor = color || '#0af';
      marker.style.background = markerColor;
      // Set marker text color for contrast
      function getContrastYIQ(hexcolor) {
        hexcolor = hexcolor.replace('#', '');
        if (hexcolor.length === 3) {
          hexcolor = hexcolor[0]+hexcolor[0]+hexcolor[1]+hexcolor[1]+hexcolor[2]+hexcolor[2];
        }
        const r = parseInt(hexcolor.substr(0,2),16);
        const g = parseInt(hexcolor.substr(2,2),16);
        const b = parseInt(hexcolor.substr(4,2),16);
        const yiq = ((r*299)+(g*587)+(b*114))/1000;
        return (yiq >= 128) ? '#111' : '#fff';
      }
      marker.style.color = getContrastYIQ(markerColor);
      // Drag logic (mouse)
      marker.addEventListener('dragstart', function(e) {
        // Check if drawing is allowed (rotation must be 0 degrees)
        if (!isDrawingAllowed()) {
          showRotationWarning();
          e.preventDefault();
          return;
        }
        e.dataTransfer.setData('text/plain', '');
        this.style.opacity = '0.5';
        marker._dragStartX = e.clientX;
        marker._dragStartY = e.clientY;
        marker._origLeft = parseFloat(marker.style.left);
        marker._origTop = parseFloat(marker.style.top);
      });
      marker.addEventListener('dragend', function(e) {
        // Check if drawing is allowed (rotation must be 0 degrees)
        if (!isDrawingAllowed()) {
          showRotationWarning();
          this.style.opacity = '1';
          return;
        }
        this.style.opacity = '1';
        const mapContainer = marker.parentElement;
        const rect = mapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        this.style.left = (x * 100) + '%';
        this.style.top = (y * 100) + '%';
        // Update marker in array
        const markers = getCurrentMarkers();
        const idx = Array.from(mapContainer.querySelectorAll('.text-marker')).indexOf(marker);
        if (markers[idx]) {
          markers[idx].x = x;
          markers[idx].y = y;
          // Auto-save uploaded map data
          if (currentMap.startsWith('uploaded_')) {
            saveUploadedMaps();
          }
        }
      });
      // Touch drag logic
      let touchDragging = false;
      let touchStartX, touchStartY, origLeft, origTop;
      marker.addEventListener('touchstart', function(e) {
        // Check if drawing is allowed (rotation must be 0 degrees)
        if (!isDrawingAllowed()) {
          showRotationWarning();
          return;
        }
        if (e.touches.length !== 1) return;
        touchDragging = true;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        origLeft = parseFloat(marker.style.left);
        origTop = parseFloat(marker.style.top);
        marker.style.opacity = '0.5';
      }, { passive: false });
      marker.addEventListener('touchmove', function(e) {
        if (!touchDragging || e.touches.length !== 1) return;
        // Check if drawing is allowed (rotation must be 0 degrees)
        if (!isDrawingAllowed()) {
          showRotationWarning();
          touchDragging = false;
          marker.style.opacity = '1';
          return;
        }
        e.preventDefault();
        const mapContainer = marker.parentElement;
        const rect = mapContainer.getBoundingClientRect();
        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;
        // Convert px to %
        const newLeft = ((origLeft / 100) * rect.width + dx) / rect.width * 100;
        const newTop = ((origTop / 100) * rect.height + dy) / rect.height * 100;
        marker.style.left = newLeft + '%';
        marker.style.top = newTop + '%';
      }, { passive: false });
      marker.addEventListener('touchend', function(e) {
        if (!touchDragging) return;
        touchDragging = false;
        marker.style.opacity = '1';
        // Check if drawing is allowed (rotation must be 0 degrees)
        if (!isDrawingAllowed()) {
          showRotationWarning();
          return;
        }
        const mapContainer = marker.parentElement;
        const rect = mapContainer.getBoundingClientRect();
        const left = parseFloat(marker.style.left) / 100;
        const top = parseFloat(marker.style.top) / 100;
        // Update marker in array
        const markers = getCurrentMarkers();
        const idx = Array.from(mapContainer.querySelectorAll('.text-marker')).indexOf(marker);
        if (markers[idx]) {
          markers[idx].x = left;
          markers[idx].y = top;
          // Auto-save uploaded map data
          if (currentMap.startsWith('uploaded_')) {
            saveUploadedMaps();
          }
        }
      }, { passive: false });
      // Double-click to edit
      marker.addEventListener('dblclick', function() {
        // Check if drawing is allowed (rotation must be 0 degrees)
        if (!isDrawingAllowed()) {
          showRotationWarning();
          return;
        }
        const newText = prompt('Edit marker text:', marker.textContent);
        if (newText) {
          marker.textContent = newText;
          marker.setAttribute('aria-label', `Tactical marker: ${newText}`);
          // Update marker in array
          const mapContainer = marker.parentElement;
          const markers = getCurrentMarkers();
          const idx = Array.from(mapContainer.querySelectorAll('.text-marker')).indexOf(marker);
          if (markers[idx]) {
            markers[idx].text = newText;
            // Ensure color is preserved
            markers[idx].color = color;
            // Auto-save uploaded map data
            if (currentMap.startsWith('uploaded_')) {
              saveUploadedMaps();
            }
          }
        }
      });
      // Right-click to delete
      marker.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        // Check if drawing is allowed (rotation must be 0 degrees)
        if (!isDrawingAllowed()) {
          showRotationWarning();
          return;
        }
        const mapContainer = marker.parentElement;
        const markers = getCurrentMarkers();
        const idx = Array.from(mapContainer.querySelectorAll('.text-marker')).indexOf(marker);
        if (idx > -1) {
          markers.splice(idx, 1);
        }
        marker.remove();
      });
      return marker;
    }

    // Keyboard shortcuts for Undo/Redo
    document.addEventListener('keydown', function(e) {
      // Ignore if focused on input or textarea
      const tag = document.activeElement.tagName.toLowerCase();
      if (tag === 'input' || tag === 'textarea') return;
      // Undo: Ctrl+Z or Cmd+Z
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        undoDrawing();
      }
      // Redo: Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z
      if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
        e.preventDefault();
        redoDrawing();
      }
    });

    // Sidebar toggle for mobile and sidebar logic
    document.addEventListener('DOMContentLoaded', function() {
      var mapSelect = document.getElementById('sidebarMapSelect');
      if (mapSelect) mapSelect.selectedIndex = 0;
      const sidebar = document.querySelector('.sidebar');
      const toggleBtn = document.getElementById('sidebarToggle');

      function closeSidebar() {
        sidebar.classList.remove('open');
        var overlay = document.getElementById('sidebarOverlay');
        if (overlay) overlay.style.display = 'none';
      }
      function openSidebar() {
        sidebar.classList.add('open');
        var overlay = document.getElementById('sidebarOverlay');
        if (overlay) overlay.style.display = 'block';
      }
      function setSidebarInitialState() {
        if (window.innerWidth <= 768) {
          closeSidebar(); // Always closed on mobile by default
        } else {
          openSidebar();  // Always open on desktop
        }
      }
      if (toggleBtn && sidebar) {
        toggleBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          openSidebar();
        });
        var overlay = document.getElementById('sidebarOverlay');
        if (overlay) {
          overlay.addEventListener('click', function() {
            closeSidebar();
          });
        }
      }
      setSidebarInitialState();
      window.addEventListener('resize', setSidebarInitialState);
    });

    // FAB logic for mobile
    function isMobile() {
      return window.innerWidth <= 768;
    }
    function closeFabMenu() {
      document.getElementById('fab').classList.remove('open');
    }
    document.addEventListener('DOMContentLoaded', function() {
      // ... existing sidebar toggle ...
      // FAB setup
      const fab = document.getElementById('fab');
      const fabMainBtn = document.getElementById('fabMainBtn');
      const fabMenu = document.getElementById('fabMenu');
      if (fab && fabMainBtn && fabMenu) {
        fabMainBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const isOpen = fab.classList.toggle('open');
          fabMainBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
        });
        // Close FAB menu when clicking outside
        document.addEventListener('click', function(e) {
          if (isMobile() && fab.classList.contains('open') && !fab.contains(e.target)) {
            closeFabMenu();
          }
        });
        // FAB actions
        document.getElementById('fabAddMarker').onclick = function() { addMarkerGlobal(); closeFabMenu(); };
        document.getElementById('fabSaveBoard').onclick = function() { saveBoard(); closeFabMenu(); };
        document.getElementById('fabExportBoard').onclick = function() { exportAsImage(); closeFabMenu(); };
        document.getElementById('fabClearBoard').onclick = function() { resetCanvas(); closeFabMenu(); };
        document.getElementById('fabUndo').onclick = function() { undoDrawing(); closeFabMenu(); };
        document.getElementById('fabRedo').onclick = function() { redoDrawing(); closeFabMenu(); };
        document.getElementById('fabInstall').onclick = function() { installApp(); closeFabMenu(); };
      }
    });

    // Color button logic (single handler for marker color)
    document.addEventListener('DOMContentLoaded', function() {
      // Route color buttons
      const routeBtns = document.querySelectorAll('.route-color-btn');
      routeBtns.forEach(btn => {
        btn.addEventListener('click', function() {
          currentRouteColor = btn.getAttribute('data-color');
          routeBtns.forEach(b => b.style.outline = 'none');
          btn.style.outline = `2px solid ${currentRouteColor}`;
        });
      });
      // Marker color buttons (single handler)
      const markerBtns = document.querySelectorAll('.marker-color-btn');
      markerBtns.forEach(btn => {
        btn.addEventListener('click', function() {
          currentMarkerColor = btn.getAttribute('data-color');
          markerBtns.forEach(b => b.style.outline = 'none');
          btn.style.outline = `2px solid ${currentMarkerColor}`;
        });
      });
      // Set default outline on page load
      markerBtns.forEach(btn => {
        if (btn.getAttribute('data-color') === currentMarkerColor) {
          btn.style.outline = `2px solid ${currentMarkerColor}`;
        }
      });
    });

    // Ensure FAB/mobile Add Marker also uses the correct color
    document.addEventListener('DOMContentLoaded', function() {
      const fabAddMarkerBtn = document.getElementById('fabAddMarker');
      if (fabAddMarkerBtn) {
        fabAddMarkerBtn.onclick = function() { addMarkerGlobal(); closeFabMenu(); };
      }
    });

    // Wire up Add Marker buttons after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      var sidebarAddMarkerBtn = document.getElementById('sidebarAddMarkerBtn');
      if (sidebarAddMarkerBtn) {
        sidebarAddMarkerBtn.onclick = addMarkerGlobal;
      }
      var fabAddMarkerBtn = document.getElementById('fabAddMarker');
      if (fabAddMarkerBtn) {
        fabAddMarkerBtn.onclick = function() { addMarkerGlobal(); closeFabMenu(); };
      }
    });

    // Check for Update button logic
    document.addEventListener('DOMContentLoaded', function() {
      const checkUpdateBtn = document.getElementById('checkUpdateBtn');
      if (checkUpdateBtn) {
        checkUpdateBtn.onclick = function() {
          if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistration().then(function(reg) {
              if (reg) {
                reg.update().then(function() {
                  if (reg.waiting) {
                    reg.waiting.postMessage({ type: 'SKIP_WAITING' });
                    setTimeout(function() { window.location.reload(); }, 500);
                  } else {
                    alert('No update available.');
                  }
                });
              } else {
                alert('No service worker registered.');
              }
            });
          } else {
            alert('Service workers are not supported in this browser.');
          }
        };
      }
    });

    // 1. Hardcoded bomb sites and spawns for 'standoff'
    const mapSitesAndSpawns = {
      standoff: {
        bombSites: [
          { type: "A", x: 0.209, y: 0.425 },
          { type: "B", x: 0.409, y: 0.587 }
        ],
        spawns: [
          { type: "attacker", x: 0.649, y: 0.207 },
          { type: "defender", x: 0.209, y: 0.768 }
        ]
      }
      // Add more maps as needed
    };

    // 2. Draw bomb sites and spawns on the canvas
    function drawSitesAndSpawns() {
      const canvas = getActiveCanvas();
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const mapData = mapSitesAndSpawns[currentMap];
      if (!mapData) return;

      // Bomb Sites
      mapData.bombSites.forEach(site => {
        const x = site.x * canvas.width;
        const y = site.y * canvas.height;
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, 18, 0, 2 * Math.PI);
        ctx.fillStyle = site.type === "A" ? "#e53935" : "#1976d2";
        ctx.fill();
        ctx.font = "bold 18px Arial";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(site.type, x, y);
        ctx.restore();
      });

      // Spawns
      mapData.spawns.forEach(spawn => {
        const x = spawn.x * canvas.width;
        const y = spawn.y * canvas.height;
        ctx.save();
        // Use compact label
        const label = spawn.type === "attacker" ? "Atk" : "Def";
        ctx.font = "bold 13px Arial";
        const rectWidth = 40;
        const rectHeight = 22;
        const radius = 6;
        // Draw smaller rounded rectangle
        ctx.beginPath();
        ctx.moveTo(x - rectWidth/2 + radius, y - rectHeight/2);
        ctx.lineTo(x + rectWidth/2 - radius, y - rectHeight/2);
        ctx.quadraticCurveTo(x + rectWidth/2, y - rectHeight/2, x + rectWidth/2, y - rectHeight/2 + radius);
        ctx.lineTo(x + rectWidth/2, y + rectHeight/2 - radius);
        ctx.quadraticCurveTo(x + rectWidth/2, y + rectHeight/2, x + rectWidth/2 - radius, y + rectHeight/2);
        ctx.lineTo(x - rectWidth/2 + radius, y + rectHeight/2);
        ctx.quadraticCurveTo(x - rectWidth/2, y + rectHeight/2, x - rectWidth/2, y + rectHeight/2 - radius);
        ctx.lineTo(x - rectWidth/2, y - rectHeight/2 + radius);
        ctx.quadraticCurveTo(x - rectWidth/2, y - rectHeight/2, x - rectWidth/2 + radius, y - rectHeight/2);
        ctx.closePath();
        ctx.fillStyle = spawn.type === "attacker" ? "#ff9800" : "#43a047";
        ctx.fill();
        // Draw text
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(label, x, y);
        ctx.restore();
      });
    }

    // Image upload and processing functions
    function isStorageNearLimit(newDataSizeBytes = 0) {
      let total = 0;
      for (let key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
          total += ((localStorage[key].length + key.length) * 2); // bytes
        }
      }
      return (total + newDataSizeBytes) > 4.9 * 1024 * 1024; // ~5MB
    }

    function resizeImage(file) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
          // Calculate new dimensions (max 1920px width or height)
          const maxSize = 1920;
          let { width, height } = img;
          
          if (width > height) {
            if (width > maxSize) {
              height = (height * maxSize) / width;
              width = maxSize;
            }
          } else {
            if (height > maxSize) {
              width = (width * maxSize) / height;
              height = maxSize;
            }
          }
          
          // Resize image
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          
          // Convert to base64
          const base64 = canvas.toDataURL('image/jpeg', 0.9);
          resolve(base64);
        };
        
        img.src = URL.createObjectURL(file);
      });
    }

    function addUploadedMap(base64Data, fileName) {
      uploadCounter++;
      const mapId = `uploaded_${uploadCounter}`;
      const mapName = fileName.replace(/\.[^/.]+$/, ""); // Remove file extension
      
      // Create map entry HTML
      const mapEntry = document.createElement('div');
      mapEntry.className = 'map-entry';
      mapEntry.id = mapId;
      mapEntry.style.display = 'none';
      
      mapEntry.innerHTML = `
        <div class="map-container">
          <!-- .map-content wrapper exists only to sync rotation between image and canvas -->
          <div class="map-content">
            <img id="${mapId}MapImage" src="${base64Data}" alt="${mapName} Map">
            <canvas id="${mapId}DrawingCanvas"></canvas>
          </div>
        </div>
      `;
      
      // Add to main content
      document.querySelector('main').appendChild(mapEntry);
      
      // Add to custom uploaded maps list
      addToUploadedMapsList(mapId, mapName);
      
      // Store map data
      uploadedMaps[mapId] = {
        name: mapName,
        base64: base64Data
      };
      
      // Setup canvas for the new map with improved timing for uploaded maps
      const canvas = document.getElementById(`${mapId}DrawingCanvas`);
      if (canvas) {
        setupCanvas(canvas);
        // Additional delay for uploaded maps to ensure proper rendering
        requestAnimationFrame(() => {
          setTimeout(() => {
            const mapImg = document.getElementById(`${mapId}MapImage`);
            if (mapImg && mapImg.complete) {
              // Trigger a single resize for the uploaded map
              const canvas = document.getElementById(`${mapId}DrawingCanvas`);
              if (canvas && canvas.dataset.resized !== 'true') {
                // Direct resize call with debouncing
                if (canvas.resizeTimeout) {
                  clearTimeout(canvas.resizeTimeout);
                }
                canvas.resizeTimeout = setTimeout(() => {
                  if (canvas.dataset.resized !== 'true') {
                    canvas.dataset.resized = 'true';
                    const parent = canvas.parentElement;
                    const img = parent.querySelector('img');
                    if (img && img.complete && img.naturalWidth > 0) {
                      const rect = img.getBoundingClientRect();
                      const width = Math.round(rect.width);
                      const height = Math.round(rect.height);
                      if (width > 0 && height > 0) {
                        canvas.width = width;
                        canvas.height = height;
                        canvas.style.width = width + 'px';
                        canvas.style.height = height + 'px';
                        canvas.style.left = '0px';
                        canvas.style.top = '0px';
                        redraw();
                      }
                    }
                    setTimeout(() => {
                      canvas.dataset.resized = 'false';
                    }, 100);
                  }
                }, 50);
              }
            }
          }, 100);
        });
      }
      
      // Add to drawing state
      mapDrawings[mapId] = { drawings: [], undone: [] };
      mapMarkers[mapId] = [];
      
      // Save to localStorage
      saveUploadedMaps();
      
      return mapId;
    }

    function handleImageUpload(file) {
      const statusDiv = document.getElementById('uploadStatus');
      statusDiv.textContent = 'Processing image...';
      statusDiv.className = 'upload-status';
      
      resizeImage(file)
        .then(base64Data => {
          // Storage limit check before saving
          if (isStorageNearLimit(base64Data.length * 2)) {
            alert('Storage is full. Please delete older uploads to continue.');
            statusDiv.textContent = '';
            statusDiv.className = 'upload-status';
            document.getElementById('imageUpload').value = '';
            return;
          }
          const mapId = addUploadedMap(base64Data, file.name);
          
          // Switch to the uploaded map
          switchMap(mapId);
          
          // Update selector
          const mapSelector = document.getElementById('sidebarMapSelect');
          mapSelector.value = mapId;
          
          statusDiv.textContent = 'Upload successful!';
          statusDiv.className = 'upload-status success';
          
          // Clear the file input
          document.getElementById('imageUpload').value = '';
        })
        .catch(error => {
          console.error('Upload error:', error);
          statusDiv.textContent = 'Upload failed. Please try again.';
          statusDiv.className = 'upload-status error';
        });
    }

    // Rename functionality
    function renameUploadedMap(mapId) {
      const currentName = uploadedMaps[mapId]?.name || '';
      const newName = prompt('Enter new name for this map:', currentName);
      
      if (newName && newName.trim() && newName !== currentName) {
        // Update the stored name
        uploadedMaps[mapId].name = newName.trim();
        
        // Update the display
        updateUploadedMapName(mapId, newName.trim());
        
        // Update the alt text of the image
        const mapImg = document.getElementById(`${mapId}MapImage`);
        if (mapImg) {
          mapImg.alt = `${newName.trim()} Map`;
        }
        
        // Save to localStorage
        saveUploadedMaps();
        
        console.log(`Map renamed from "${currentName}" to "${newName.trim()}"`);
      }
    }

    function createRenameButton(mapId) {
      const button = document.createElement('button');
      button.className = 'rename-btn';
      button.innerHTML = '‚úèÔ∏è';
      button.title = 'Rename this map';
      button.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        renameUploadedMap(mapId);
      };
      return button;
    }

    function addToUploadedMapsList(mapId, mapName) {
      const uploadedMapsList = document.getElementById('uploadedMapsList');
      if (!uploadedMapsList) return;
      
      const mapItem = document.createElement('div');
      mapItem.className = 'uploaded-map-item';
      mapItem.setAttribute('data-map-id', mapId);
      
      const mapNameSpan = document.createElement('span');
      mapNameSpan.className = 'uploaded-map-name';
      mapNameSpan.textContent = `üìÅ ${mapName}`;
      
      const renameBtn = createRenameButton(mapId);
      // Create Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'rename-btn';
      deleteBtn.innerHTML = 'üóëÔ∏è';
      deleteBtn.title = 'Delete this map';
      deleteBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (confirm('Delete this uploaded map?')) {
          // Remove from uploadedMaps
          delete uploadedMaps[mapId];
          // Remove drawing and marker state
          delete mapDrawings[mapId];
          delete mapMarkers[mapId];
          // Remove map entry from DOM
          const mapEntry = document.getElementById(mapId);
          if (mapEntry) mapEntry.remove();
          // Save to localStorage
          saveUploadedMaps();
          // Re-render uploaded maps list
          renderUploadedMapsList();
          // If the deleted map was selected, switch to the first built-in map
          if (currentMap === mapId) {
            const mapSelector = document.getElementById('sidebarMapSelect');
            if (mapSelector && mapSelector.options.length > 0) {
              for (let i = 0; i < mapSelector.options.length; i++) {
                if (!mapSelector.options[i].value.startsWith('uploaded_')) {
                  switchMap(mapSelector.options[i].value);
                  mapSelector.value = mapSelector.options[i].value;
                  break;
                }
              }
            }
          }
        }
      };
      
      mapItem.appendChild(mapNameSpan);
      mapItem.appendChild(renameBtn);
      mapItem.appendChild(deleteBtn);
      
      // Add click handler to switch to this map
      mapItem.addEventListener('click', (e) => {
        if (e.target !== renameBtn) {
          switchMap(mapId);
          updateSelectedMapItem(mapId);
        }
      });
      
      // Insert at the top of the list
      if (uploadedMapsList.firstChild) {
        uploadedMapsList.insertBefore(mapItem, uploadedMapsList.firstChild);
      } else {
        uploadedMapsList.appendChild(mapItem);
      }
    }

    // Helper to re-render the uploaded maps list
    function renderUploadedMapsList() {
      const uploadedMapsList = document.getElementById('uploadedMapsList');
      if (!uploadedMapsList) return;
      uploadedMapsList.innerHTML = '';
      Object.keys(uploadedMaps).forEach(mapId => {
        addToUploadedMapsList(mapId, uploadedMaps[mapId].name);
      });
    }

    function updateSelectedMapItem(mapId) {
      // Remove selected class from all items
      document.querySelectorAll('.uploaded-map-item').forEach(item => {
        item.classList.remove('selected');
      });
      
      // Add selected class to current map
      const currentItem = document.querySelector(`[data-map-id="${mapId}"]`);
      if (currentItem) {
        currentItem.classList.add('selected');
      }
    }

    function updateUploadedMapName(mapId, newName) {
      // Update in the custom list
      const mapItem = document.querySelector(`[data-map-id="${mapId}"]`);
      if (mapItem) {
        const nameSpan = mapItem.querySelector('.uploaded-map-name');
        if (nameSpan) {
          nameSpan.textContent = `üìÅ ${newName}`;
        }
      }
    }

    // Render uploaded images with delete buttons (for keys starting with 'upload_')
    function renderUploads() {
      const container = document.getElementById('uploadsContainer');
      if (!container) return;
      container.innerHTML = '';
      let found = false;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('upload_')) {
          found = true;
          const dataUrl = localStorage.getItem(key);
          const wrapper = document.createElement('div');
          wrapper.style.display = 'flex';
          wrapper.style.alignItems = 'center';
          wrapper.style.marginBottom = '0.5rem';
          const img = document.createElement('img');
          img.src = dataUrl;
          img.alt = key;
          img.style.maxWidth = '60px';
          img.style.maxHeight = '60px';
          img.style.marginRight = '0.5rem';
          img.style.borderRadius = '6px';
          img.style.border = '1px solid #333';
          const delBtn = document.createElement('button');
          delBtn.textContent = 'üóëÔ∏è Delete';
          delBtn.style.marginLeft = '0.5rem';
          delBtn.style.background = '#222';
          delBtn.style.color = '#ff4444';
          delBtn.style.border = '1px solid #444';
          delBtn.style.borderRadius = '5px';
          delBtn.style.cursor = 'pointer';
          delBtn.onclick = function() {
            localStorage.removeItem(key);
            renderUploads();
          };
          wrapper.appendChild(img);
          wrapper.appendChild(delBtn);
          container.appendChild(wrapper);
        }
      }
      if (!found) {
        container.innerHTML = '<div style="color:#888;font-size:0.95em;">No uploaded images found.</div>';
      }
    }

    // Call renderUploads on page load
    document.addEventListener('DOMContentLoaded', renderUploads);

    // Robust map rotation logic - targets .map-content to rotate both image and canvas together
    function rotateActiveMap() {
      // Find the currently visible map entry by checking all map entries
      let visibleMapEntry = null;
      const allMapEntries = document.querySelectorAll('.map-entry');
      
      for (const entry of allMapEntries) {
        if (entry.style.display !== 'none' && entry.offsetParent !== null) {
          visibleMapEntry = entry;
          break;
        }
      }
      
      if (!visibleMapEntry) {
        console.warn('No visible map entry found for rotation');
        return;
      }
      
      // Get the map content wrapper within the visible map entry - this wraps both image and canvas
      const activeMapContent = visibleMapEntry.querySelector('.map-content');
      if (!activeMapContent) {
        console.warn('No map content wrapper found in visible map entry:', visibleMapEntry.id);
        return;
      }
      
      // Remove any previous rotation classes
      activeMapContent.classList.remove('rot-90', 'rot-180', 'rot-270');
      
      // Get current rotation from data attribute
      let rot = parseInt(activeMapContent.getAttribute('data-rot') || '0', 10);
      rot = (rot + 90) % 360;
      
      // Apply the correct rotation class to sync image and canvas rotation
      if (rot === 90) {
        activeMapContent.classList.add('rot-90');
      } else if (rot === 180) {
        activeMapContent.classList.add('rot-180');
      } else if (rot === 270) {
        activeMapContent.classList.add('rot-270');
      }
      
      // Save current rotation
      activeMapContent.setAttribute('data-rot', rot);
      
      // Debug log
      console.log('Rotated map to', rot, 'degrees');
      console.log('Active map content:', activeMapContent);
      console.log('Visible map entry ID:', visibleMapEntry.id);
    }

    // Attach rotate handler after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      const rotateBtn = document.getElementById('rotateMapBtn');
      if (rotateBtn) {
        rotateBtn.onclick = rotateActiveMap;
      }
    });
  </script>

  <!-- On DOMContentLoaded, visually indicate the default selected marker color -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Set default outline for marker color buttons
      const markerBtns = document.querySelectorAll('.marker-color-btn');
      markerBtns.forEach(btn => {
        if (btn.getAttribute('data-color') === currentMarkerColor) {
          btn.style.outline = `2px solid ${currentMarkerColor}`;
        }
      });
    });
  </script>

  <!-- Add logic to show update button when a new SW is waiting -->
  <script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').then(reg => {
      if (reg.waiting) {
        document.getElementById('update-btn').style.display = 'block';
      }
      reg.addEventListener('updatefound', () => {
        const newWorker = reg.installing;
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            document.getElementById('update-btn').style.display = 'block';
          }
        });
      });
    });
    document.getElementById('update-btn').onclick = function() {
      location.reload();
    };
  }
  </script>
</body>
</html>



